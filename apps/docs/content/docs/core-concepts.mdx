---
title: Core concepts
description: How Better Blog is structured and key APIs
---

### Package structure

- `better-blog`: types, schemas, utilities, and memory DB helpers
- `better-blog/queries`: query helpers (`getOrCreateQueryClient`, query keys)
- `better-blog/hooks`: React hooks (client)
- `better-blog/client`: `BlogPageRouter` and page components (client-only)
- `better-blog/context`: `BlogProvider`, context and UI types
- `better-blog/router`: route helpers (`matchRoute`, `resolveLoadingComponent`)
- `better-blog/server/pages`: SSR/SSG adapter (`createBlogServerAdapter`)
- `better-blog/api`: API router (`createBlogApiRouter`)
- `better-blog/sitemap`: sitemap generation (`createBlogSitemap`)
- `better-blog/providers/sql`: SQL provider exports
- `better-blog/providers/prisma`: Prisma provider exports
- `better-blog/providers/drizzle`: Drizzle provider exports
- `better-blog/providers/memory`: In-memory demo provider

### Data provider

You inject a `BlogDataProvider` implementation (CMS, files, API, DB):

```ts
export interface BlogDataProvider {
  getAllPosts: (filter?: {
        slug?: string
        tag?: string
        offset?: number
        limit?: number
        query?: string
        published?: boolean
        locale?: string
    }) => Promise<Post[]>
    getPostBySlug?: (slug: string, options?: { locale?: string }) => Promise<Post | null>
    createPost?: (input: PostCreateExtendedInput) => Promise<Post>
    updatePost?: (slug: string, input: PostUpdateExtendedInput) => Promise<Post>
    deletePost?: (slug: string) => Promise<void>
}
```

### Architecture

- Schema-driven routes and data; minimal state in components
- Strict client/server separation via dedicated entry points

### TanStack Query

Why we use it:

- **Caching + de/rehydration**: Server prefetch + client hydration for SEO and zero-flash data
- **Great DX**: Automatic refetching, pagination support, and easy overrides

