---
title: Core concepts
description: How Better Blog is structured and key APIs
---

### Package structure

- `better-blog`: shared utilities and types
- `better-blog/client`: client components (`BlogRouterPage`, `BetterBlogContextProvider`, hooks)
- `better-blog/server`: server adapters (e.g. `createServerAdapter` for SSR/SSG)

### Data provider

You inject a `BlogDataProvider` implementation (CMS, files, API, DB):

```ts
export interface BlogDataProvider {
  getAllPosts: (filter?: { slug?: string; tag?: string; offset?: number; limit?: number }) => Promise<Post[]>;
  getPostBySlug?: (slug: string) => Promise<Post | null>;
  // optional create/update/delete for admin flows
  createPost?: (input: unknown) => Promise<Post>;
  updatePost?: (slug: string, input: unknown) => Promise<Post>;
  deletePost?: (slug: string) => Promise<void>;
}
```

### API surface (most used)

- **Server utilities** (`better-blog`)
  - `matchRoute(slug?: string[]): RouteMatch`
  - `generateStaticRoutes(): Array<{ slug: string[] }>`
  - `generatePostMetadata(post: Post): { title: string; description?: string; image?: string }`
- **Server adapter** (`better-blog/server`)
  - `createServerAdapter(serverConfig: BlogDataProvider, queryClient: QueryClient)` â†’ `{ generateStaticParams, generateMetadata, Entry }`
- **Client** (`better-blog/client`)
  - `BetterBlogContextProvider`, `BlogRouterPage`
  - Hooks: `usePosts`, `usePost`, `useTagPosts`, `useDrafts`, `useCreatePost`, `useUpdatePost`, `useDeletePost`

### Architecture (high-level)

- Schema-driven routes and data; minimal state in components
- Strict client/server separation via dedicated entry points
- Key modules live under `src/lib/better-blog/*` in this repo

### TanStack Query setup

Why we use it:

- **Caching + de/rehydration**: Server prefetch + client hydration for SEO and zero-flash data
- **Great DX**: Automatic refetching, pagination support, and easy overrides

Add a small helper to create/reuse a `QueryClient` in both server and browser environments.

Create `lib/get-query-client.ts`:

```ts
import {
  QueryClient,
  defaultShouldDehydrateQuery,
  isServer,
} from '@tanstack/react-query';

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000,
      },
      dehydrate: {
        // Include pending queries in dehydration (useful for Suspense)
        shouldDehydrateQuery: (query) =>
          defaultShouldDehydrateQuery(query) || query.state.status === 'pending',
      },
    },
  });
}

let browserQueryClient: QueryClient | undefined = undefined;

export function getQueryClient() {
  if (isServer) {
    // Server: always make a new query client
    return makeQueryClient();
  }
  // Browser: reuse a single instance to avoid remounts across Suspense
  if (!browserQueryClient) browserQueryClient = makeQueryClient();
  return browserQueryClient;
}
```

